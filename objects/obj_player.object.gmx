<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize Variables
grav = 0.5;
hsp = 0;
vsp = 0;
max_vsp = 10;
movespeed = 8;
jumps = 0;
jumpsmax = 2;
jumpspeed = 12;

walking = false;
jumping = false;
falling = false;
crouching = false;
hurting = false;
dying = false;
grounded = false;
facing_right = true;

timepassed = 0;

moving_platform = 0;
on_moving_wall = 0;

/*
if (global.checkpointR == room)
{
    x = global.checkpointx;
    y = global.checkpointy;
}

key_down = 0;
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check for Collisions

/**
 * Is Colliding with a Moving Wall
 */

// if inside a moving wall
var inst = instance_place(x, y, obj_moving_wall);
if (inst != noone)
{
    var hsp_temp = 0;
    
    // if the wall is moving left and is to the right of the object
    if (inst.hsp &lt; 0 &amp;&amp; inst.bbox_left &gt; bbox_left)
    {
        hsp_temp = inst.bbox_left - bbox_right;
        hsp_temp += sign(hsp_temp);
    }
    // else, if the wall is moving right and is to the left of this object
    else if (inst.hsp &gt; 0 &amp;&amp; inst.bbox_right &lt; bbox_right)
    {
        hsp_temp = inst.bbox_right - bbox_left;
        hsp_temp += sign(hsp_temp);
    }
    
    // check if the object can be separated horizontally from the wall
    if (hsp_temp != 0)
    {
        if ( ! place_meeting(x + hsp_temp, y, obj_wall))
        {
            x += hsp_temp;
        }
    }
    
    var vsp_temp = 0;
    
    // if the wall is moving up and is lower than the object
    if (inst.vsp &lt; 0 &amp;&amp; inst.bbox_bottom &gt; bbox_bottom)
    {
        vsp_temp = inst.bbox_top - bbox_bottom;
        vsp_temp += sign(vsp_temp);
    }
    // else, if the wall is moving down is and higher than this object
    else if (inst.vsp &gt; 0 &amp;&amp; inst.bbox_top &lt; bbox_top)
    {
        vsp_temp = inst.bbox_bottom - bbox_top;
        vsp_temp += sign(vsp_temp);
    }
    
    // check if the object can be separated vertically from the wall
    if (vsp_temp != 0)
    {
        if ( ! place_meeting(x, y + vsp_temp, obj_wall))
        {
            y += vsp_temp;
        }
    }
}

// if riding a moving wall
var inst = instance_place(x, y + vsp, obj_moving_wall);
if (inst != noone)
{
    // check if the object can be repositioned horizontally along with the platform
    var hsp_temp = inst.hsp;
    if (place_meeting(x + hsp_temp, y, obj_wall))
    {
        while ( ! place_meeting(x + sign(hsp_temp), y, obj_wall))
        {
            x += sign(hsp_temp);
        }
        hsp_temp = 0;
    }
    x += hsp_temp;
}

// if was standing on a descending wall during the Begin Step
if (on_moving_wall != 0)
{
    if (instance_exists(on_moving_wall))
    {
        if (on_moving_wall.y &gt; on_moving_wall.yprevious)
        {
            // check if the object can be repositioned vertically along with the wall
            var vsp_temp = on_moving_wall.vsp;
            if (place_meeting(x, y + vsp_temp, obj_wall))
            {
                while ( ! place_meeting(x, y + sign(vsp_temp), obj_wall))
                {
                    y += sign(vsp_temp);
                }
                vsp_temp = 0;
            }
            y += vsp_temp;
        }
    }
}


/**
 * Is Colliding with Sloped Walls
 */

// check horizontal collision with slopes (using precision mask)
if (place_meeting(x + hsp, y, obj_wall_slope))
{
    var yoffset = 0;
    var ysteps = abs(hsp * 1);
    
    // if hsp has been reduced to zero, then there isn't an open space to move into
    while (place_meeting(x + hsp, y + yoffset, obj_wall) &amp;&amp; hsp != 0)
    {
        yoffset -= 1;
        
        // if an open vertical space couldn't be found
        if (yoffset &lt; -ysteps)
        {
            // move back one horizontally and try again
            yoffset = 0;
            hsp -= sign(hsp);
        }
    }
    y += yoffset;
}


/**
 * Is Colliding with Walls
 */

// check horizontal collision
if (place_meeting(x + hsp, y, obj_wall))
{
    while ( ! place_meeting(x + sign(hsp), y, obj_wall))
    {
        x += sign(hsp);
    }
    hsp = 0;
}
x += hsp;

// check vertical collision
if (place_meeting(x, y + vsp, obj_wall))
{
    while ( ! place_meeting(x, y + sign(vsp), obj_wall))
    {
        y += sign(vsp);
    }
    vsp = 0;
}
y += vsp;


/*
// make sure the object isn't outside the room
if (bbox_left &lt; 0 || bbox_right &gt;= room_width)
{
    x = clamp(x, x - bbox_left, room_width - 1 - (bbox_right - x));
}
*/

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Check for Collisions

/**
 * Is Colliding with a Moving Platform
 */

/*
moving_platform = 0;

// if standing on (or inside) a moving platform
var inst = instance_place(x, y + 1, obj_moving_platform);
if (inst != noone)
{
    // if this platform moves down during the Step,
    // this object will need to move with it during the End Step
    moving_platform = inst;
}
*/

// if standing on (or inside) a moving wall at start of Step
on_moving_wall = 0;
var inst = instance_place(x, y + 1, obj_moving_wall);
if (inst != noone)
{
    // if this wall descends during the Step,
    // the object will need to descend with it during the End Step
    on_moving_wall = inst;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update

// get the player's input
key_left = keyboard_check(vk_left);
key_right = keyboard_check(vk_right);
key_down = keyboard_check(vk_down);
key_jump = keyboard_check(vk_space);
key_jump_pressed = keyboard_check_pressed(vk_space);
key_jump_released = keyboard_check_released(vk_space);

// is object standing on a wall
grounded = place_meeting(x, y + 1, obj_wall);
//grounded = position_meeting(x, bbox_bottom + 1, obj_wall);
//show_debug_message(grounded);

// reset walking
hsp = 0;
walking = false;
    
// apply gravity
if (vsp &lt; max_vsp)
{
    vsp += grav;
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Is Crouching
if ( ! hurting &amp;&amp; ! dying &amp;&amp; ! jumping &amp;&amp; ! jumping)
{
    // if grounded and pressing the DOWN button
    if (grounded &amp;&amp; key_down)
    {
        crouching = true;
    }
    
    // if crouching and no longer pressing the DOWN button
    if (crouching &amp;&amp; ! key_down)
    {
        crouching = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Is Jumping or Falling
if ( ! hurting &amp;&amp; ! dying &amp;&amp; ! crouching)
{
    // if jumping again while in the air
    if (jumping &amp;&amp; jumps &lt; jumpsmax &amp;&amp; key_jump_pressed)
    {
        jumps++;
        vsp = -jumpspeed;
    }
    
    /*
    if (key_jump)
    {
        vsp = -jumpspeed;
    }
    
    if (vsp &lt; 0 &amp;&amp; ! key_jump_held)
    {
        vsp = max(vsp, 0);
    }
    */
    
    
    // if grounded and just pressed the JUMP button
    if (grounded &amp;&amp; ! jumping &amp;&amp; key_jump_pressed)
    {
        jumping = true;
        grounded = false;
        vsp = -jumpspeed;
    }
    
    // reduce jump height
    if (jumping &amp;&amp; vsp &lt; 0 &amp;&amp; key_jump_released)
    {
        vsp = vsp / 2;
    }
    
    // if falling
    if (vsp &gt; 0 &amp;&amp; ! grounded)
    {
        falling = true;
    }
    
    // if grounded after jumping or falling
    if ((jumping || falling) &amp;&amp; grounded)
    {
        jumps = 0;
        jumping = false;
        falling = false;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Is Moving
if ( ! dying &amp;&amp; ! hurting &amp;&amp; ! crouching)
{    
    if (key_left)
    {
        hsp = -movespeed;
        walking = true;
    }
    else if (key_right)
    {
        hsp = movespeed;
        walking = true;
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update Object Sprite

// update the direction the object is facing
if (facing_right &amp;&amp; key_left)
{
    image_xscale = -1;
    facing_right = false;
}
else if ( ! facing_right &amp;&amp; key_right)
{
    image_xscale = 1;
    facing_right = true;
}

// update the object's sprite
if (crouching)
{
    sprite_index = spr_player;
    image_speed = 0;
    image_index = 1;
}
/*else if (walking)
{
    sprite_index = spr_player_walk;
    image_speed = 0.3;
}*/
else
{
    sprite_index = spr_player;
    image_speed = 0;
    image_index = 0;
}

/*
// Control the sprites
if (yprevious != y) {
    sprite_index = spr_player_jump;
    image_speed = 0;
    image_index = y &gt; yprevious;
} else {
    if (xprevious != x) {
        sprite_index = spr_player_walk;
        image_speed = 0.1;
    } else {
        sprite_index = spr_player_stand;
    }
}
*/

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
